---
title: "Files & the File System"
subtitle: "Modern Plain Text Computing<br />Week 01b"
format: kjhslides-revealjs
engine: knitr
filters: 
  - invert-h1
  - include-code-files
author:
  - name: Kieran Healy
    email: kieran.healy@duke.edu
date: last-modified
---

```{r}
#| label: setup
#| include: false
#| echo: false
#| warning: false
#| message: false

library(kjhslides)

kjh_register_tenso()
kjh_set_knitr_opts()
kjh_set_slide_theme()

library(tidyverse)
library(flipbookr)

```

# Files

## What is a file?

:::: {.columns}

::: {.column width="60%"}

![](../assets/01-file-system/01_file_cabinet_hierarchy.png){width=90%}


:::

::: {.column width="35%"}

You very likely have never used one of these. Perhaps you've never even seen one in real life.

:::

::::

::: aside

Illustration: @peek02:_unix_power_tools [p. 21]

:::


## The file cabinet!

:::: {.columns}

::: {.column width="50%"}


![](../assets/01-file-system/01_filing_cabinet.png){width=50%}

:::

::: {.column width="50%"}

"Could capitalism, surveillance, and governance have developed in
the twentieth century without filing cabinets? Of course, but only if
there had been another way to store and circulate paper efficiently;
if that had been the case, that technology would be the object of this
book." --- @robertsonFilingCabinetVertical2021 [p.3]

:::

::::

::: {.notes}
"The ubiquity of the filing cabinet in the twentieth-century office space, along with its noticeable absence of style, has obscured its transformative role in the histories of both information technology and work. In the first in-depth history of this neglected artifact, Craig Robertson explores how the filing cabinet profoundly shaped the way that information and data have been sorted, stored, retrieved, and used.

Invented in the 1890s, the filing cabinet was a result of the nineteenth-century faith in efficiency. Previously, paper records were arranged haphazardly: bound into books, stacked in piles, curled into slots, or impaled on spindles. The filing cabinet organized loose papers in tabbed folders that could be sorted alphanumerically, radically changing how people accessed, circulated, and structured information.

Robertson’s unconventional history of the origins of the information age posits the filing cabinet as an information storage container, an “automatic memory” machine that contributed to a new type of information labor privileging manual dexterity over mental deliberation. Gendered assumptions about women’s nimble fingers helped to naturalize the changes that brought women into the workforce as low-level clerical workers. The filing cabinet emerges from this unexpected account as a sophisticated piece of information technology and a site of gendered labor that with its folders, files, and tabs continues to shape how we interact with information and data in today’s digital world."

:::

## The file cabinet!

::::: {.columns}

:::: {.column width="50%"}


![](../assets/01-file-system/01_filing_cabinet_manual.png){width=75% .lightbox}

::::

:::: {.column width="50%"}

::: {style="font-size: 70%;"}
"Cabinet logic involves the creation of interior compartments to organize storage space according to classification and indexing systems ... Partitions made from paper, not wood, divided storage space to create rigorous order; these partitions took the form of tabbed manila folders separated by tabbed guide cards. This iteration of the logic dispensed with a separate index to make paper discoverable by utilizing the “very organization of the material and its location” with the “vertical guides serving as locating medium.” Elimination of an index was signaled in filing literature by the terms “direct alphabet index” and “automatic index” ... Without the need to consult a separate index, a clerk grouped papers together on their edge behind tabs labeled with classifications, so any given paper could be found quickly." --- [@robertsonFilingCabinetVertical2021, p.104-5]

:::

::::

:::::

::: {.notes}
"The ubiquity of the filing cabinet in the twentieth-century office space, along with its noticeable absence of style, has obscured its transformative role in the histories of both information technology and work. In the first in-depth history of this neglected artifact, Craig Robertson explores how the filing cabinet profoundly shaped the way that information and data have been sorted, stored, retrieved, and used.

Invented in the 1890s, the filing cabinet was a result of the nineteenth-century faith in efficiency. Previously, paper records were arranged haphazardly: bound into books, stacked in piles, curled into slots, or impaled on spindles. The filing cabinet organized loose papers in tabbed folders that could be sorted alphanumerically, radically changing how people accessed, circulated, and structured information.

Robertson’s unconventional history of the origins of the information age posits the filing cabinet as an information storage container, an “automatic memory” machine that contributed to a new type of information labor privileging manual dexterity over mental deliberation. Gendered assumptions about women’s nimble fingers helped to naturalize the changes that brought women into the workforce as low-level clerical workers. The filing cabinet emerges from this unexpected account as a sophisticated piece of information technology and a site of gendered labor that with its folders, files, and tabs continues to shape how we interact with information and data in today’s digital world."

:::


## Index cards

:::: {.columns}
::: {.column width="70%"}
![](../assets/01-file-system/01_library_index-card_shelf.png){width=90%}
:::

::: {.column width="30%" .right}

Like a filing cabinet, but smol

:::
::::



## Index cards

![](../assets/01-file-system/01_library_index_cards.png){width=90%}



# Automating Information and Control

## A music box

![](../assets/01-file-system/01_music_box.png){width=100%}

## A Jacquard Loom

![](../assets/01-file-system/01_jacquard_loom.png){width=100%}


## Jacquard Loom Cards

![](../assets/01-file-system/01_jacquard_loom_card_2.png){width=100%}


# Tabulation Machines

## Hollerith Cards

![](../assets/01-file-system/01_hollerith_card.png){width=100%}


::: {.notes}
"At the end of the 1800s Herman Hollerith invented the recording of data on a medium that could then be read by a machine,[dubious – discuss][13][14][15][16] developing punched card data processing technology for the 1890 U.S. census.[17] His tabulating machines read and summarized data stored on punched cards and they began use for government and commercial data processing.
Initially, these electromechanical machines only counted holes, but by the 1920s they had units for carrying out basic arithmetic operations.[18]: 124  Hollerith founded the Tabulating Machine Company (1896) which was one of four companies that were amalgamated via stock acquisition to form a fifth company, Computing-Tabulating-Recording Company (CTR) (1911), later renamed International Business Machines Corporation (IBM) (1924). Other companies entering the punched card business included The Tabulator Limited (Britain, 1902), Deutsche Hollerith-Maschinen Gesellschaft mbH (Dehomag) (Germany, 1911), Powers Accounting Machine Company (US, 1911), Remington Rand (US, 1927), and H.W. Egli Bull (France, 1931).[19] These companies, and others, manufactured and marketed a variety of punched cards and unit record machines for creating, sorting, and tabulating punched cards, even after the development of electronic computers in the 1950s."
:::

## Hollerith Machines

![](../assets/01-file-system/01_hollerith_tabulator.png){width=100%}


## Hollerith Machines

![](../assets/01-file-system/01_hollerith_card_1890_yellow.png){width=100%}


## Hollerith Machines

![](../assets/01-file-system/01_hollerith_card_1890_decoder_fields.png){width=100%}

::: {.notes}
|               |                              |                                                           |                                     |
|---------------|------------------------------|-----------------------------------------------------------|-------------------------------------|
| Field 1       | Civil War Veterans           | CM, CL, CS: Marine, Sailor, Soldier                       | Confederate Army                    |
|               |                              | UM, UL, US: Marine, Sailor, Soldier                       | United States Army                  |
| Field 2       | Relationship (family)        | Hd: Head of Household                                     | Mb: Member of family                |
|               |                              | Wf: Wife                                                  | O: Other                            |
| Field 3       | Race                         | Jp: Japanese                                              | In: Civilized Indian (taxpaying)    |
|               |                              | Ch: Chinese                                               | Mu: Mulatto                         |
|               |                              | B: Negro                                                  | Qd: Quadroon                        |
|               |                              | W: White                                                  | Oc: Octoroon                        |
| Field 4       | Gender                       | Male or Female                                            |                                     |
| Field 5 & 6   | Your Age                     | Combination of numbers                                    | 0: if under 1 year old              |
|               |                              | Un: Unknown                                               | Mo: \# of months if a baby          |
| Field 7       | Conjugal Condition           | Dv: Divorced                                              | Mr: Married more than 1 year        |
|               |                              | Un: Unknown                                               | CY: Married this year               |
|               |                              | Wd: Widow/Widower                                         | (in the Census Year)                |
|               |                              | Sg: Single                                                |                                     |
| Field 8       | \# of Children born          | Up to 19 children                                         |                                     |
| Field 9       | \# of Children alive         | Up to 19 children                                         |                                     |
| Field 10 & 11 | Your birthplace              | Combination of upper case letters                         | St: birth was in state of residence |
|               |                              | and lower case letters                                    | Un: Unknown                         |
| Field 12      | Mother’s birthplace          | Two Letter Country Codes                                  |                                     |
| Field 13      | Father’s birthplace          | Two Letter Country Codes                                  |                                     |
| Field 14      | \# of years in the US        |                                                           |                                     |
| Field 15      | Citizenship for Foreign-born | Al: Alien                                                 | Pa: First Papers submitted          |
|               |                              | Na: Naturalized citizen                                   | Un: Unknown                         |
| Field 16 & 17 | Occupation                   | Combination of upper case letters  and lower case letters | NG: Not Gainfully employed or       |
|               |                              |                                                           | in School                           |
| Field 18      | Unemployed                   | 1-12: Months unemployed                                   | Oc                                  |
|               |                              |                                                           | O                                   |
| Field 19      | Education                    | OK: Can read and write                                    | ————-OR———–                         |
|               |                              | W: Can read but not write                                 | 1-9: Number of months in school     |
|               |                              | R: : Can write but not read                               | 0: : Not in school                  |
| Field 20      | Language Spoken              | Un: Understand English?                                   | Ft: Father’s language               |
|               |                              | En: English                                               | Mt: Mother’s language               |
|               |                              | Ot: Other                                                 |                                     |
| Field 21      | Tenure                       | Fh: Farm Hired (Rented)                                   | Hh: Home Hired (Rented)             |
|               |                              | FM: Farm Owned (w/ mortgage)                              | Hf: Home owned Free and clear       |
|               |                              | Ff: Farm owned Free and clear                             | Hm: Home Owned (w/ mortgage)        |
|               |                              | X: : Does not apply                                       |                                     |
| Far Left Side | Location                     | State, county, city,: local divisions and                 | Enumerator District                 |
|               |                              |                                                           |                                     |
:::

## Hollerith Operators {.smaller}

:::: {.columns}
::: {.column width="70%"}
  ![](../assets/01-file-system/01_hollerith_operator_01.png){width=80% .lightbox}  
:::

::: {.column width="30%" .right}
  Demonstrating a older card-puncher, probably to show how things had improved with census tabulation methods. This is likely the "Before" picture with a roll from the 1890 Census. The card-puncher is a [Pantograph](https://en.wikipedia.org/wiki/Pantograph).
:::
::::




## Hollerith Operators {.smaller}

:::: {.columns}
::: {.column width="70%"}
  ![](../assets/01-file-system/01_hollerith_operator_02.png){width=80% .lightbox}  
:::

::: {.column width="30%" .right}
  Same woman as the previous photo; her colleague on the right is demonstrating the newer, faster IBM Type 001 Key Puncher. (Again, probably a re-enactment / demo of earlier techniques.) 
:::
::::



# Programmable Computers

## IBM punch cards

:::: {.columns}
::: {.column width="70%"}
  ![](../assets/01-file-system/01_ibm_punch_card_verifiers.png){width=100%}    
:::

::: {.column width="30%" .right}
  In the longer term, punch card writers got much more efficient.
:::
::::

## IBM punch cards

![](../assets/01-file-system/01_ibm_card.png){width=100%}

An IBM punch card is 80 columns wide. The first CRT terminals displayed 80 columns of text for this reason. You'll see 80 columns of text pop up as a standard in all kinds of places. 


## Big Iron {.smaller}

:::: {.columns}
::: {.column width="70%"}
![](../assets/01-file-system/01_ibm_system_360.png){width=80%}  
:::

::: {.column width="30%" .right}
No screens! Paper in, paper out for the operator; magnetic tapes for storage in the background. This is an IBM/360, the most important class of mainframe in the 1960s and early 1970s.


::::: {style="font-size: 70%; color: #C0C0C0;"}
One thing that's hard to convey in pictures is the way that---because of all the daisy-wheel or tractor-fed printing, mechanical card processing, and huge reels of tape spinning up and down---rooms like this were _loud_.
:::::

:::
::::

## Storage

:::: {.columns}
::: {.column width="70%"}
![](../assets/01-file-system/01_bryant_hard_drive1.png){width=60%}

:::

::: {.column width="30%" .right}
Notice that the "File" here is the machine itself, or at most a single disk platter.
:::
::::


## Storage {.smaller}

:::: {.columns}
::: {.column width="55%"}
  ![](../assets/01-file-system/01_bryant_hard_drive_2.png){width=90%}
:::

::: {.column width="45%" .right}
The older way of speaking is still with us, as when we speak of someone's "Application File" or "Tenure File"; that is, a file is a collection of related documents. 
  
But the newer way, where "file" means "a single document", is now dominant, especially in computing.
:::
::::


# What Files Are

## A file is a [metaphor]{.fg-yellow}

- Your computer does not have "files" in the way that a filing cabinet has files. 
- A file is an [abstraction]{.fg-lblue}, a way of naming and organizing data on your computer that at a lower-level is "just zeros and ones" (and at a lower level than _that_ is just patterns in some physical substrate that can be _interpreted_ as zeros and ones)
- The file metaphor in computing dates most prominently to the development of the Unix operating system in the early 1970s
- Files are organized in filesystems

## There are many kinds of files

- As many as there are kinds of application.
- Files have the name someone gives them. `My Thesis`, `term_paper`, and so on.
- There's a longstanding (though weak) convention about using file extensions, tagged on to the end of a name, to signal _to users_ what kind of file it is: `term_paper.docx`, `.xlsx`, `.ppt`, `.pdf`, `.sqlite`, `.png`, `.jpg`, `.ps`, `.mp3`, `.mp4`, `.gif`, `.csv`, `.Rmd`, `.qmd`, `.md`, `.txt`.
- Files don't know what their extension is, a bit like how electrons don't know what color the outside of their copper wire is.

## Binary and Plain Text files

- Understanding the general notion of "encoding information" is a very rich and deep topic that, sadly, we are going to skip.
- If a file is in some binary format then in general you won't be able to read its contents just by looking inside it. You will need an application that understands the file's particular format; i.e. the way that information in it is encoded. 
- A `.jpg` file uses a set of rules to store numbers that can be interpreted as corresponding to things like the hue and location of a pixel. But _you_ won't see a picture if you look inside a `.jpg` file using a text editor. You'll need an application that knows how to read `.jpg` files.

## What is Plain Text?

- Text files, though, are sort of special. What's visibly in them appears to correspond much more closely to what they represent. A plain text file seems to represent the letter "A" with a symbol that looks like an "A". So much so that we can say it _is_ an "A".   

- That means that when you look at a text file you can see what is in it immediately. And editing the contents of the file is the same as editing its text. 

- There's still an "encoding" of course! It's still necessary to have an application that can read the text file and display it on a screen, etc. But what's inside seems much closer to being immediately interpretable "just by looking", because most of it is letters and numbers. 

## But wait!

::::: {.fragment fragment-index=1}
- _I thought you said computers just store ones and zeros?_
:::::

::::: {.fragment fragment-index=2}
- Yes this is true. In `ASCII` encoding, for instance, an "A" is really just conventionally the symbol represented by the seven-bit binary number `1000001`, which exists on some sort of storage medium (an SSD, a Hard Disk, a floppy disk, a punch card, a reel of paper, whatever) in such a way that some device can read its contents.

:::::

::::: {.fragment fragment-index=3}
- ASCII is the **A**merican **S**tandard **C**ode for **I**nformation **I**nterchange. It was first specified in 1963.
:::::

## ASCII 

::: {style="font-size: 85%;"}

The venerable and now outdated [ASCII](https://en.wikipedia.org/wiki/ASCII) character set: 26 uppercase letters; 26 lowercase letters; 10 digits; 32 printable symbols; and 33 control characters ultimately derived from telegraph code and teletype machines.

:::

:::: {.columns}
::: {.column width="70%"}

```{r}
#| echo: FALSE
readxl::read_xlsx(here::here("files", "examples", "ascii_table.xlsx")) |> 
  mutate(Binary = str_pad(Binary, width = 7, pad = "0")) |> 
  kableExtra::kbl() |> 
  kableExtra::kable_styling(fixed_thead = TRUE) |> 
  kableExtra::scroll_box(height = "400px", 
                         width = "700px", 
                         box_css = "border: 0px; padding: 5px;")
                    
```

:::

::: {.column width="30%" .right}
  ![](../assets/01-file-system/01_teletype_model_33.png){width=100%}
:::
::::




## Modern Text: Unicode and UTF-8

- ASCII is a seven bit system that only has $2^7$ or 128 "code points" — i.e. individual slots that could represent anything. It left out all kinds of things. (Other alphabets, for instance. Also any diacritics or accents. And any number of symbols.)
- Eight bit computers allowed for 256 code points. The second 128 never had a single standard for what they should represent. The most common extension was [ISO-8859-1](https://en.wikipedia.org/wiki/ISO/IEC_8859-1) or "Latin1" encoding, but there were others too. This created conflicts and confusion when a program or application expecting text encoded according to one standard was fed text encoded with a different standard.   

## Modern Text: Unicode and UTF-8

- Encoding conflicts are why you still sometimes see this sort of thing on web pages: "CafÃ©"  or "Caf◻" instead of "Café".
- It is surprisingly difficult to establish the encoding of a large text file that doesn't explicitly declare how it's encoded in some sort of metadata. (You can guess, but it can be super-annoying.)
- Nowadays this has _mostly_ been resolved by the adoption of [Unicode](https://home.unicode.org) and its simplest and most widespread encoding, [UTF-8](https://en.wikipedia.org/wiki/UTF-8), which extends ASCII to 1,112,064 code points. It uses between one and four eight-bit elements to represent particular character glyphs.
- Many older datasets may still be encoded in something other than UTF-8, however. 


# Organizing Files

## Input/Output

- Beginning in the 1970s, computing rapidly moves away from print I/O and towards screens. 
- Storage capacity and processing power increase radically (and get much smaller) with the development of hard drives and integrated circuits.
- We get to a point where our "Teletype" interface with the machine is purely metaphorical: this is the _command line_ or _console_.
- And after that, in the late 1970s and early 1980s, an entirely new set of metaphors gets introduced: files represented by "icons" inside "windows", first on on a metaphorical "desktop" and then later on a more abstract touch-based surface.

## A late-model teletype (TTY) machine

![](../assets/01-file-system/01_teletype_telex_machine.png)


## The DEC VT-100 Terminal (1978)

![](../assets/01-file-system/01_dec_vt100.png)

## The IBM PC (1981)

![](../assets/01-file-system/01_ibm_pc_5150.png)

## The Apple Macintosh (1984)

![](../assets/01-file-system/01_apple_macintosh.png)


## The macOS Terminal app icon

![](../assets/01-file-system/01_macos_terminal_icon.png)


## This is where we came in

- The "Office" and "Engineering" models really start to diverge in the 1980s
- A lot of computing gets done using the Engineering model and its metaphors, even as the Office model comes to dominate. 
- But many of these **newer systems remain built on top of the world made out of the older metaphors**. And in particular, the idea of _named files_ living in a _hierarchical file system_ that are acted on in sequence through _written instructions_ remains extremely important for many computing tasks.
- Especially the stuff we need to do.

# Back to the file system

## Files {.smaller}

:::: {.columns}

::: {.column width="45%"}

![](../assets/01-file-system/01_file_cabinet_hierarchy.png){width=100%}


:::

::: {.column width="55%"}

- Our data is stored --- or represented as being stored --- in a _file system_.
- This is, again, a way of organizing items for our benefit.
- The UNIX operating system developed at Bell Labs codifies the modern "file" metaphor. 
- Files are named items that live in a [hierarchical file system]{.fg-lblue}. "Ordinary" documents like `notes.txt` are thought of as files, which seems natural to us now.
- The hierarchy is made of [folders]{.fg-lblue} or "directories" that, like a filing cabinet, can nest inside one another and inside larger storage units. 
- By navigating the hierarchy from its [root]{.fg-red},     we can trace a [path]{.fg-lblue} to any particular file.


:::

::::



## Files

- A file is just a stream of bytes, of data, some sort of resource that a program can read or interact with.
- In the UNIX way of thinking, "[Everything is a file]{.fg-lblue}"
- That is, lots of things that are not normally thought of as files (such as printers, or terminal screens, or connections to other computers) can be thought of as living in a named place somewhere in the filesystem.
- The basic set of UNIX utilities can be thought of as tools that accept "files" (as a standard stream of input data), perform some specific action on them (read, print, move, copy, delete, count lines, find text, whatever) and then return a standard stream of output data that can be sent to the console, used as input to another command, or become a file of its own.

## File system hierarchy {.smaller}

![](../assets/01-file-system/01_file_system_example.png){width="70%"}

::: aside

Illustration: @peek02:_unix_power_tools [p. 23]

:::

## Path conventions

- `/` represents a division in the file hierarchy. You can think of it as a branch point on a tree, or as a new level of nesting in a series of boxes, or as the action "Go inside" or "Enter".

- On a Unix-like system, a full path to a file looks like this: 

```{r}
#| echo: false
fs::fs_path(here::here("slides", "01b-slides.qmd"))
```

"Go inside the '`Users`' folder, then inside the '`kjhealy`' folder, then inside '`Documents`' then inside '`courses`' then '`mptc`' then '`slides`' and you will find the file `01b-slides.qmd`."

## Standard locations 

- `/` : root. Everything lives inside or under the root.
- `/bin/`  : For _binaries_. Core user executable programs and tools.
- `/sbin/` : System binaries. Essential executables for the super user (who is also called `root`)
- `/lib/` : Support files for executables. 
- `/usr/` : Conventionally, stuff installed "locally" for users in addition to the core system. Will contain its own `bin/` and `lib/` subdirs.
- `/usr/local` : Files that the local user has compiled or installed
- `/opt/` : Like `/usr/`, another place for locally installed software to go.


## Standard locations

- These locations get mapped together in the `$PATH`, which is an _environment variable_ that tells the system where executables can be found. 

```{.zsh}
❯ echo $PATH
/home/kjhealy/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/snap/bin
```

- Delimited by `:` and searched in order from left to right.
- To learn where a command is being executed from, use `which`

```{.zsh}
❯ which R
/usr/local/bin/R
```

## Standard locations 

- `/` : root. Everything lives inside or under the root.
- `/bin/`  : For _binaries_. Core user executable programs and tools.
- `/sbin/` : System binaries. Essential executables for the super user (who is also called `root`)
- `/lib/` : Support files for executables. 
- `/usr/` : Conventionally, stuff installed "locally" for users in addition to the core system. Will contain its own `bin/` and `lib/` subdirs.
- `/usr/local` : Files that the local user has compiled or installed
- `/opt/` : Like `/usr/`, another place for locally installed software to go.
- `/etc/` : Editable text configuration. Config files often go here. 


## Standard locations 

-  `/home/` or `/Users/` : Where the accounts of individual system users live, like `/Users/kjhealy/`


```{.zsh}
❯ pwd
/home/kjhealy
❯  ls
bin  certbot.log  logrotate.conf  old  projects  public  staging
```

## File system hierarchy {.smaller}

- An edited version of the root `/` tree

```{.text include="../files/misc/root-tree.txt"}
```

## File system hierarchy {.smaller}

- An edited version of the user or home tree

```{.text include="../files/misc/home-tree.txt"}
```

## Navigating the tree

Who am I?

```{zsh}
whoami
```


Where am I?

```{zsh}
pwd
```

What is my purpose in life?
 
```{zsh}
fortune
```


## Navigating the tree

What is in here?

```{zsh}
ls
```


## Navigating the tree

```{zsh}
cd files
ls  
cd ..
```


## Navigating the tree


```{zsh}
ls -l                                                                                           
```

Note the idea of commands having options, or _switches_. 

## Navigating the tree


```{zsh}
ls / 
```

The `~` character is a shortcut to the top of your home directory:

```{.zsh}
❯ cd ~
❯ ls
bin  certbot.log  logrotate.conf  old  projects  public  staging
```


##  Path rules

- If the path name begins with `/`, it is an _absolute_ path, starting from the root.
- If the path name begins with `~`, it will usually be expanded into an absolute path name starting at your home directory (`~`).

##  Path rules

- If the pathname does not begin with a `/` or `~` then the path name is relative to the current directory. 

- Two relative special cases use entries that are in every Unix directory:
    a. If the path name begins with `./`, the path is relative to the current directory, e.g., `./textfile`, though this can also execute the file if it is given executable file permissions.
    b. If the path name begins with `../`, the path is relative to the parent of the current directory. For example, if your current directory is `/Users/kjhealy/Documents/papers` then `../data` means `/Users/kjhealy/Documents/data`


## File permissions

Who is using this file system anyway?

```{.zsh}
drwxr-xr-x@  8 kjhealy  staff    256 Aug 15 16:35 R
-rw-r--r--@  1 kjhealy  staff   1210 Aug 15 20:29 README.md
```

Unix derives from a world there there are multiple users and groups of users who are all using slices (in terms of processor time and available permanent storage) of a large central computer.


## File permissions

```{.zsh}
drwxr-xr-x@  8 kjhealy  staff    256 Aug 15 16:35 R
-rw-r--r--@  1 kjhealy  staff   1210 Aug 15 20:29 README.md
```

In Unix systems there are three kinds of owner: the _user_ (here `kjhealy`), the _group_ (here `staff`), and _others_ or other users on the system.

## File permissions

```{.zsh}
drwxr-xr-x@  8 kjhealy  staff    256 Aug 15 16:35 R
-rw-r--r--@  1 kjhealy  staff   1210 Aug 15 20:29 README.md
```


Three things you can do to a file: 

### [r]{.fg-lblue}ead
### [w]{.fg-orange}rite
### e[x]{.fg-red}ecute

- For files, "read" means _open_; "write" means _edit, save, or delete_; "execute" means _run_ if it's an application or script.
- For directories, "read" means _list contents_ with ls, "write' means _create, delete, or rename_; "execute" means access or enter using `cd`


## File permissions

::: {style="font-size: 80%;"}

`❯ ls -l README.md`

`-rw-r--r--@  1 kjhealy  staff   1210 Aug 15 20:29 README.md`

:::

&nbsp; 

These permissions say `rw-r--r--` or 

- The _user_ can `rw-` read and write this file
- The _group_ can `r--` read this file
- The _world_ can `r--` read this file

Executable permissions are irrelevant here because it's a text file.


## File permissions

![](../assets/01-file-system/01_unix_permission_bits.png){width="70%"}


- We change file permissions with the `chmod` command. So e.g. `chmod 644 README.md` means "change the permissions to `rw-r--r--`".


# The Unix way of thinking
 
## Stepping back

- Your computer [stores files]{.fg-lblue} and [runs commands]{.fg-orange}.
- The files are stored in a large hierarchy called a [filesystem]{.fg-green}.
- You issue instructions to run particluar commands at a [command line]{.fg-lblue} that is provided by a [shell]{.fg-orange}, which is how you the user talk to the [operating system]{.fg-orange}.
- Unix commands and utilities generally try to do a _specific_ thing to files or running processes. 
- The Unix conception of a 'file' is very flexible. Connections to other computers  can act like files.
- Unix commands are often [composable]{.fg-red} using [pipes]{.fg-red}.

## The Unix pipe

- Unix commands work with some _input_ and may produce some _output_
- Unix systems have the concepts of "standard input", "standard output", and "standard error" as streams where things come from, where they go to, and where problems are reported. 

## The Unix pipe

- More on this next week, but for now think about the output of a command like `ls`: 


```{zsh}
ls 
```

## The Unix pipe

We can send, or _pipe_, this output to another command, instead of to the terminal:

```{zsh}
ls | wc -l
```

- The `wc` command counts the number of words in a file, or in whatever is sent to it via `STDIN`. 
- The `-l` switch to `wc` means 'just count lines instead of words'

## The Unix pipe

Like with pipelines in R, we can compose sequences of actions at the prompt:

```{.zsh}
❯ ls -lh access.log
-rw-r--r-- 1 root root 7.0M Aug 29 16:00 access.log
```


```{.zsh}
❯ head access.log
192.195.49.31 - - [27/Aug/2023:00:01:11 +0000] "GET / HTTP/1.1" 200 19219 "https://www.google.com/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:12 +0000] "GET /libs/tufte-css-2015.12.29/tufte.css HTTP/1.1" 200 2025 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:12 +0000] "GET /libs/tufte-css-2015.12.29/envisioned.css HTTP/1.1" 200 888 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:12 +0000] "GET /css/tablesaw-stackonly.css HTTP/1.1" 200 1640 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:12 +0000] "GET /css/nudge.css HTTP/1.1" 200 1675 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:12 +0000] "GET /css/sourcesans.css HTTP/1.1" 200 1492 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:13 +0000] "GET /js/jquery.js HTTP/1.1" 200 30464 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:13 +0000] "GET /js/tablesaw-stackonly.js HTTP/1.1" 200 2996 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
192.195.49.31 - - [27/Aug/2023:00:01:13 +0000] "GET /js/nudge.min.js HTTP/1.1" 200 937 "https://socviz.co/" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.54"
52.13.187.67 - - [27/Aug/2023:00:01:13 +0000] "GET /dataviz-pdfl_files/figure-html4/ch-03-fig-lexp-gdp-10-1.png HTTP/1.1" 200 308830 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:72.0) Gecko/20100101 Firefox/72.0"
```


## The Unix pipe

Like with pipelines in R, we can compose sequences of actions at the prompt:

```{.zsh}
❯ head access.log | awk '// {print $11}'

"https://www.google.com/"
"https://socviz.co/"
"https://socviz.co/"
"https://socviz.co/"
"https://socviz.co/"
"https://socviz.co/"
"https://socviz.co/"
"https://socviz.co/"
"https://socviz.co/"
"-"
```

## The Unix pipe

Like with pipelines in R, we can compose sequences of actions at the prompt:

```{.zsh}
❯ awk '// {print $11}' access.log | sort | uniq -c | sort -nr | head -n 15

   9729 "https://socviz.co/lookatdata.html"
   4851 "-"
   4212 "https://socviz.co/"
   1719 "https://socviz.co/makeplot.html"
   1477 "https://bookdown.org/"
   1466 "https://socviz.co/gettingstarted.html"
   1373 "https://socviz.co/groupfacettx.html"
    864 "https://socviz.co/workgeoms.html"
    794 "https://socviz.co/maps.html"
    733 "https://socviz.co/refineplots.html"
    671 "https://socviz.co/index.html"
    349 "https://socviz.co/appendix.html"
    228 "https://socviz.co/modeling.html"
    153 "https://www.google.com/"
     50 "http://vissoc.co/"
```

## The Unix pipe

We can do a lot with a pipeline:

```{zsh}
curl -s 'http://api.citybik.es/v2/networks/citi-bike-nyc' |
   jq '.network.stations[].free_bikes' | 
  gpaste -sd+ | 
  bc
```

This is the number of Citi Bikes available in New York City at the time these slides were made.

We usually won't use the Unix command line or shell to things like this. But it remains extremely handy for many more common tasks. 

::: aside
CitiBike example courtesy of Jeroen Janssens
:::

# Envoi

---

:::{.huge .center}
::::{.absolute top="1%"}
In an era of Generative AI and LLMs, why are we covering this stuff?
::::
:::


---

:::{.huge .center} 
::::{.absolute top="30%"}
Because [Unix]{.fg-lblue} is still [everywhere]{.fg-pink}
::::
:::

::: aside
And will be for a long time to come, I'm afraid.
:::

--- 

## "Why am I doing this?" 

- As soon as you try to do anything of any sort of technical complexity, or just simple [reproducibility]{.fg-red}, with your computer---even using the newest and coolest tools---I promise [you'll eventually find yourself in a world governed by the metaphors and methods Unix originated]{.fg-lblue}, and, very likely, in a literal Unix-derived environment. 

- That is, you will be in some sort of [folder-based hierarchy]{.fg-lblue}; you will edit [plain-text files]{.fg-orange} in order to configure, launch, generate, or capture the output of applications; and you will do this by way of [instructions written down as a series of commands]{.fg-red} that follow some sort of regular syntax. The details of those instructions (the particular conventions they use to express what they mean) will vary depending on the task at hand. But in essence you will always be doing the same thing. 
